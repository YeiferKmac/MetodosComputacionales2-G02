# -*- coding: utf-8 -*-
"""Punto 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/juand4g/MetodosComputacionales2-G02/blob/main/Tarea%201/Punto%201.ipynb
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from numpy.polynomial.polynomial import Polynomial
from scipy.signal import savgol_filter
from scipy.signal import find_peaks
from scipy.signal import peak_widths
import os


# Obtener la ruta absoluta del directorio donde está el archivo .py
script_dir = os.path.dirname(os.path.abspath(__file__))

# Combinar la ruta del directorio con el nombre del archivo
file_path = os.path.join(script_dir, 'Rhodium.csv')


data = pd.read_csv(file_path)

#Calcular promedio de diferencias entre datos consecutivos
prom_dx = 0
n = len(data["Intensity (mJy)"])
i = 0
while i < n-1:
  intensity = data["Intensity (mJy)"][i]
  intensity_next = data["Intensity (mJy)"][i+1]
  dx = abs(intensity - intensity_next)
  prom_dx += dx
  i += 1
prom_dx = prom_dx/n

#Limpieza inicial con tolerancia 4.4
cleaned_data = data.copy()
j = 0
n_eliminados = 0
tol = 4.4
while j < n-1:
  intensity = cleaned_data["Intensity (mJy)"][j]
  intensity_next = cleaned_data["Intensity (mJy)"][j+1]
  dx = abs(intensity - intensity_next)
  if dx > tol*prom_dx:
    cleaned_data["Intensity (mJy)"][j+1] = intensity
    n_eliminados += 1
  j+=1

#Limpieza secundaria focalizada en los datos corruptos restantes, en donde la pendiente es menos pronunciada, así que es necesario usar menos tolerancia
k = 0
tol2 = 1.0
while (not (100 < k < 500)) and (k < n-1):
  intensity = cleaned_data["Intensity (mJy)"][k]
  intensity_next = cleaned_data["Intensity (mJy)"][k+1]
  dx = abs(intensity - intensity_next)
  if dx > tol2*prom_dx:
    cleaned_data["Intensity (mJy)"][k+1] = intensity
    n_eliminados += 1
  k+=1
  if k == 100:
    k = 501

print(f'1.a) Número de datos eliminados: {n_eliminados}')

def rad_fondo(x, a, b, c, d, e):
  return   a * x**4 + b * x**3 + c * x**2 + d * x + e   #polinomial grado 4

indices_picos = range(260,420)

# Crear una máscara para excluir los picos
mascara = np.ones_like(cleaned_data['Wavelength (pm)'], dtype=bool)

# Crear la máscara excluyendo los picos
mascara = ~cleaned_data.index.isin(indices_picos)
mascara_picos = ~mascara

#Suavizado de los datos con máscara
fondo_suave = savgol_filter(cleaned_data['Intensity (mJy)'][mascara], window_length=51, polyorder=3)
fondo_suave

#popt, pcov = curve_fit(rad_fondo,cleaned_data['Wavelength (pm)'][mascara], cleaned_data['Intensity (mJy)'][mascara],p0=[100,0.3,0,1,2])

#Se estima la curva utilizando la muestra con máscara y suavizada
popt, pcov = curve_fit(rad_fondo,cleaned_data['Wavelength (pm)'][mascara], fondo_suave,p0=[100,0.3,0,1,2])
a,b,c,d,e=popt

cleaned_data["frenado"] = rad_fondo(cleaned_data['Wavelength (pm)'],a,b,c,d,e)
cleaned_data["residual"] = cleaned_data['Intensity (mJy)'] - cleaned_data["frenado"]

#Se actualizan las intensidades quitando la radiación de frenado
cleaned_data['Intensity (mJy)'] = cleaned_data["Intensity (mJy)"]-cleaned_data["frenado"]
#cleaned_data['Intensity (mJy)'] = cleaned_data["Intensity (mJy)"][mascara]-fondo_suave

graph4 = plt.plot(cleaned_data["Wavelength (pm)"], cleaned_data['Intensity (mJy)'], label="Picos de rayos X (mJy)")
plt.plot(cleaned_data["Wavelength (pm)"], cleaned_data['frenado'], label="Modelo Bremsstrahlung (mJy)")
plt.gca().spines[['top', 'right']].set_visible(False)
plt.axhline(y=0, color="black", linestyle="--", linewidth=1)
plt.xlabel("Wavelength (pm)")
plt.ylabel("Intensity (mJy)")
plt.legend()
plt.savefig("picos.pdf", format="pdf")

# Encontrar los picos y calcular el ancho a media altura (FWHM)

peaks, properties = find_peaks(cleaned_data['Intensity (mJy)'], height=0, distance=10)
results_half = peak_widths(cleaned_data['Intensity (mJy)'], peaks, rel_height=0.5)
# Crear la gráfica
plt.figure(figsize=(10, 6))
plt.plot(cleaned_data["Wavelength (pm)"], cleaned_data["Intensity (mJy)"], label="Intensity (mJy)", color='blue')
# Marcar los picos
plt.scatter(
    cleaned_data["Wavelength (pm)"][peaks],
    cleaned_data["Intensity (mJy)"][peaks],
    color="red",
    label="Peaks",
    zorder=5,
)
# Agregar líneas horizontales para los anchos de los picos
plt.hlines(
    results_half[1],  # Altura donde se mide el ancho
    cleaned_data["Wavelength (pm)"][np.round(results_half[2]).astype(int)],  # Inicio
    cleaned_data["Wavelength (pm)"][np.round(results_half[3]).astype(int)],  # Fin
    color="green",
    label="Peak Widths",
)

# Etiquetas y leyenda
plt.gca().spines[['top', 'right']].set_visible(False)
plt.xlabel("Wavelength (pm)")
plt.ylabel("Intensity (mJy)")
plt.legend()
plt.title("Peaks and Widths Detection")
plt.savefig("picos_marcados.pdf", format="pdf")
plt.show()